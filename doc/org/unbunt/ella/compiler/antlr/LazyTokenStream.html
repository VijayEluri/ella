<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_14) on Fri Aug 14 23:34:47 CEST 2009 -->
<TITLE>
LazyTokenStream
</TITLE>

<META NAME="date" CONTENT="2009-08-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="LazyTokenStream";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LazyTokenStream.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyLexer.html" title="class in org.unbunt.ella.compiler.antlr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/unbunt/ella/compiler/antlr/LazyTokenStream.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LazyTokenStream.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.unbunt.ella.compiler.antlr</FONT>
<BR>
Class LazyTokenStream</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>org.unbunt.ella.compiler.antlr.LazyTokenStream</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>org.antlr.runtime.IntStream, org.antlr.runtime.TokenStream</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>LazyTokenStream</B><DT>extends java.lang.Object<DT>implements org.antlr.runtime.TokenStream</DL>
</PRE>

<P>
TODO: currently backed by a linked list - compare with an implementation backed by TreeList (commons collections)
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LazyTokenStream()">LazyTokenStream</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LazyTokenStream(org.antlr.runtime.TokenSource)">LazyTokenStream</A></B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LazyTokenStream(org.antlr.runtime.TokenSource, int)">LazyTokenStream</A></B>(org.antlr.runtime.TokenSource&nbsp;tokenSource,
                int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#collectOffChannelTokenText(int)">collectOffChannelTokenText</A></B>(int&nbsp;collectChannel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#consume()">consume</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#discardLookAhead()">discardLookAhead</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#discardTokenType(int)">discardTokenType</A></B>(int&nbsp;tokenType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.antlr.runtime.Token</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#get(int)">get</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a token at an absolute index i; 0..n-1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#getSourceName()">getSourceName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where are you getting symbols from?  Normally, implementations will
 pass the buck all the way to the lexer who can ask its input stream
 for the file name or whatever.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.antlr.runtime.TokenSource</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#getTokenSource()">getTokenSource</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where is this stream pulling tokens from?  This is not the name, but
 the object that provides Token objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#index()">index</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the current input symbol index 0..n where n indicates the
 last symbol has been read.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#isDiscardOffChannelTokens()">isDiscardOffChannelTokens</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LA(int)">LA</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get int at current input pointer + i ahead where i=1 is next int.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.antlr.runtime.Token</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LT(int)">LT</A></B>(int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get Token at current input pointer + i ahead where i=1 is next Token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#mark()">mark</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tell the stream to start buffering if it hasn't already.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#release(int)">release</A></B>(int&nbsp;marker)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You may want to commit to a backtrack but don't want to force the
 stream to keep bookkeeping objects around for a marker that is
 no longer necessary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.antlr.runtime.TokenSource</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#replaceTokenSource(org.antlr.runtime.TokenSource)">replaceTokenSource</A></B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#rewind()">rewind</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rewind to the input position of the last marker.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#rewind(int)">rewind</A></B>(int&nbsp;marker)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reset the stream so that next call to index would return marker.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#seek(int)">seek</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the input cursor to the position indicated by index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#setDiscardOffChannelTokens(boolean)">setDiscardOffChannelTokens</A></B>(boolean&nbsp;discardOffChannelTokens)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#setTokenSource(org.antlr.runtime.TokenSource)">setTokenSource</A></B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#setTokenTypeChannel(int, int)">setTokenTypeChannel</A></B>(int&nbsp;ttype,
                    int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only makes sense for streams that buffer everything up probably, but
 might be useful to display the entire stream or for testing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#toString(int, int)">toString</A></B>(int&nbsp;start,
         int&nbsp;stop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the text of all tokens from start to stop, inclusive.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#toString(org.antlr.runtime.Token, org.antlr.runtime.Token)">toString</A></B>(org.antlr.runtime.Token&nbsp;start,
         org.antlr.runtime.Token&nbsp;stop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Because the user is not required to use a token with an index stored
 in it, we must provide a means for two token objects themselves to
 indicate the start/end location.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LazyTokenStream()"><!-- --></A><H3>
LazyTokenStream</H3>
<PRE>
public <B>LazyTokenStream</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="LazyTokenStream(org.antlr.runtime.TokenSource)"><!-- --></A><H3>
LazyTokenStream</H3>
<PRE>
public <B>LazyTokenStream</B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</PRE>
<DL>
</DL>
<HR>

<A NAME="LazyTokenStream(org.antlr.runtime.TokenSource, int)"><!-- --></A><H3>
LazyTokenStream</H3>
<PRE>
public <B>LazyTokenStream</B>(org.antlr.runtime.TokenSource&nbsp;tokenSource,
                       int&nbsp;channel)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LT(int)"><!-- --></A><H3>
LT</H3>
<PRE>
public org.antlr.runtime.Token <B>LT</B>(int&nbsp;k)</PRE>
<DL>
<DD>Get Token at current input pointer + i ahead where i=1 is next Token.
 i<0 indicates tokens in the past.  So -1 is previous token and -2 is
 two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
 Return null for LT(0) and any index that results in an absolute address
 that is negative.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>LT</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="LA(int)"><!-- --></A><H3>
LA</H3>
<PRE>
public int <B>LA</B>(int&nbsp;i)</PRE>
<DL>
<DD>Get int at current input pointer + i ahead where i=1 is next int.
 Negative indexes are allowed.  LA(-1) is previous token (token
 just matched).  LA(-i) where i is before first token should
 yield -1, invalid char / EOF.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>LA</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="consume()"><!-- --></A><H3>
consume</H3>
<PRE>
public void <B>consume</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>consume</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="collectOffChannelTokenText(int)"><!-- --></A><H3>
collectOffChannelTokenText</H3>
<PRE>
public java.lang.String <B>collectOffChannelTokenText</B>(int&nbsp;collectChannel)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="get(int)"><!-- --></A><H3>
get</H3>
<PRE>
public org.antlr.runtime.Token <B>get</B>(int&nbsp;i)</PRE>
<DL>
<DD>Get a token at an absolute index i; 0..n-1.  This is really only
 needed for profiling and debugging and token stream rewriting.
 If you don't want to buffer up tokens, then this method makes no
 sense for you.  Naturally you can't use the rewrite stream feature.
 I believe DebugTokenStream can easily be altered to not use
 this method, removing the dependency.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>get</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="mark()"><!-- --></A><H3>
mark</H3>
<PRE>
public int <B>mark</B>()</PRE>
<DL>
<DD>Tell the stream to start buffering if it hasn't already.  Return
 current input position, index(), or some other marker so that
 when passed to rewind() you get back to the same spot.
 rewind(mark()) should not affect the input cursor.  The Lexer
 track line/col info as well as input index so its markers are
 not pure input indexes.  Same for tree node streams.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>mark</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="index()"><!-- --></A><H3>
index</H3>
<PRE>
public int <B>index</B>()</PRE>
<DL>
<DD>Return the current input symbol index 0..n where n indicates the
 last symbol has been read.  The index is the symbol about to be
 read not the most recently read symbol.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>index</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rewind(int)"><!-- --></A><H3>
rewind</H3>
<PRE>
public void <B>rewind</B>(int&nbsp;marker)</PRE>
<DL>
<DD>Reset the stream so that next call to index would return marker.
 The marker will usually be index() but it doesn't have to be.  It's
 just a marker to indicate what state the stream was in.  This is
 essentially calling release() and seek().  If there are markers
 created after this marker argument, this routine must unroll them
 like a stack.  Assume the state the stream was in when this marker
 was created.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>rewind</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rewind()"><!-- --></A><H3>
rewind</H3>
<PRE>
public void <B>rewind</B>()</PRE>
<DL>
<DD>Rewind to the input position of the last marker.
 Used currently only after a cyclic DFA and just
 before starting a sem/syn predicate to get the
 input position back to the start of the decision.
 Do not "pop" the marker off the state.  mark(i)
 and rewind(i) should balance still. It is
 like invoking rewind(last marker) but it should not "pop"
 the marker off.  It's like seek(last marker's input position).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>rewind</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="release(int)"><!-- --></A><H3>
release</H3>
<PRE>
public void <B>release</B>(int&nbsp;marker)</PRE>
<DL>
<DD>You may want to commit to a backtrack but don't want to force the
 stream to keep bookkeeping objects around for a marker that is
 no longer necessary.  This will have the same behavior as
 rewind() except it releases resources without the backward seek.
 This must throw away resources for all markers back to the marker
 argument.  So if you're nested 5 levels of mark(), and then release(2)
 you have to release resources for depths 2..5.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>release</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="seek(int)"><!-- --></A><H3>
seek</H3>
<PRE>
public void <B>seek</B>(int&nbsp;index)</PRE>
<DL>
<DD>Set the input cursor to the position indicated by index.  This is
 normally used to seek ahead in the input stream.  No buffering is
 required to do this unless you know your stream will use seek to
 move backwards such as when backtracking.
 <p/>
 This is different from rewind in its multi-directional
 requirement and in that its argument is strictly an input cursor (index).
 <p/>
 For char streams, seeking forward must update the stream state such
 as line number.  For seeking backwards, you will be presumably
 backtracking using the mark/rewind mechanism that restores state and
 so this method does not need to update state when seeking backwards.
 <p/>
 Currently, this method is only used for efficient backtracking using
 memoization, but in the future it may be used for incremental parsing.
 <p/>
 The index is 0..n-1.  A seek to position i means that LA(1) will
 return the ith symbol.  So, seeking to 0 means LA(1) will return the
 first element in the stream.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>seek</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public int <B>size</B>()</PRE>
<DL>
<DD>Only makes sense for streams that buffer everything up probably, but
 might be useful to display the entire stream or for testing.  This
 value includes a single EOF.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>size</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSourceName()"><!-- --></A><H3>
getSourceName</H3>
<PRE>
public java.lang.String <B>getSourceName</B>()</PRE>
<DL>
<DD>Where are you getting symbols from?  Normally, implementations will
 pass the buck all the way to the lexer who can ask its input stream
 for the file name or whatever.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getSourceName</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenSource()"><!-- --></A><H3>
getTokenSource</H3>
<PRE>
public org.antlr.runtime.TokenSource <B>getTokenSource</B>()</PRE>
<DL>
<DD>Where is this stream pulling tokens from?  This is not the name, but
 the object that provides Token objects.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getTokenSource</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTokenSource(org.antlr.runtime.TokenSource)"><!-- --></A><H3>
setTokenSource</H3>
<PRE>
public void <B>setTokenSource</B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="replaceTokenSource(org.antlr.runtime.TokenSource)"><!-- --></A><H3>
replaceTokenSource</H3>
<PRE>
public org.antlr.runtime.TokenSource <B>replaceTokenSource</B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="discardLookAhead()"><!-- --></A><H3>
discardLookAhead</H3>
<PRE>
public void <B>discardLookAhead</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTokenTypeChannel(int, int)"><!-- --></A><H3>
setTokenTypeChannel</H3>
<PRE>
public void <B>setTokenTypeChannel</B>(int&nbsp;ttype,
                                int&nbsp;channel)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="discardTokenType(int)"><!-- --></A><H3>
discardTokenType</H3>
<PRE>
public void <B>discardTokenType</B>(int&nbsp;tokenType)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDiscardOffChannelTokens()"><!-- --></A><H3>
isDiscardOffChannelTokens</H3>
<PRE>
public boolean <B>isDiscardOffChannelTokens</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDiscardOffChannelTokens(boolean)"><!-- --></A><H3>
setDiscardOffChannelTokens</H3>
<PRE>
public void <B>setDiscardOffChannelTokens</B>(boolean&nbsp;discardOffChannelTokens)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(int, int)"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>(int&nbsp;start,
                                 int&nbsp;stop)</PRE>
<DL>
<DD>Return the text of all tokens from start to stop, inclusive.
 If the stream does not buffer all the tokens then it can just
 return "" or null;  Users should not access $ruleLabel.text in
 an action of course in that case.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>toString</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(org.antlr.runtime.Token, org.antlr.runtime.Token)"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>(org.antlr.runtime.Token&nbsp;start,
                                 org.antlr.runtime.Token&nbsp;stop)</PRE>
<DL>
<DD>Because the user is not required to use a token with an index stored
 in it, we must provide a means for two token objects themselves to
 indicate the start/end location.  Most often this will just delegate
 to the other toString(int,int).  This is also parallel with
 the TreeNodeStream.toString(Object,Object).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>toString</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LazyTokenStream.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyLexer.html" title="class in org.unbunt.ella.compiler.antlr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/unbunt/ella/compiler/antlr/LazyTokenStream.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LazyTokenStream.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
