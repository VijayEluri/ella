<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_14) on Sun Aug 16 12:39:48 CEST 2009 -->
<TITLE>
LazyTokenStream
</TITLE>

<META NAME="date" CONTENT="2009-08-16">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="LazyTokenStream";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LazyTokenStream.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyLexer.html" title="class in org.unbunt.ella.compiler.antlr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/unbunt/ella/compiler/antlr/LazyTokenStream.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LazyTokenStream.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.unbunt.ella.compiler.antlr</FONT>
<BR>
Class LazyTokenStream</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>org.unbunt.ella.compiler.antlr.LazyTokenStream</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>org.antlr.runtime.IntStream, org.antlr.runtime.TokenStream</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>LazyTokenStream</B><DT>extends java.lang.Object<DT>implements org.antlr.runtime.TokenStream</DL>
</PRE>

<P>
Represents a <code>TokenStream</code> implementation which reads tokens from a given <code>TokenSource</code>
 lazily when they are requested instead of eagerly on instanciation. In addition tokens that are no longer needed
 are discarded by this token stream.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LazyTokenStream()">LazyTokenStream</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>LazyTokenStream</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LazyTokenStream(org.antlr.runtime.TokenSource)">LazyTokenStream</A></B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>LazyTokenStream</code> reading tokens from the given token source.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#collectOffChannelTokenText(int)">collectOffChannelTokenText</A></B>(int&nbsp;collectChannel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collects the tokens associated with the given token channel starting from the first look-ahead token up to the
 next token associated with the default token channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#consume()">consume</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Consumes the next token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#discardLookAhead()">discardLookAhead</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discards any look-ahead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#discardTokenType(int)">discardTokenType</A></B>(int&nbsp;tokenType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instructs this token stream to discard any tokens of the given type when they are encountered.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.antlr.runtime.Token</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#get(int)">get</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unsupported operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#getSourceName()">getSourceName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where are you getting symbols from?  Normally, implementations will
 pass the buck all the way to the lexer who can ask its input stream
 for the file name or whatever.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.antlr.runtime.TokenSource</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#getTokenSource()">getTokenSource</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where is this stream pulling tokens from?  This is not the name, but
 the object that provides Token objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#index()">index</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the current input symbol index 0..n where n indicates the
 last symbol has been read.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#isDiscardOffChannelTokens()">isDiscardOffChannelTokens</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if tokens not associated with the default token channel are discarded by this token
 stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LA(int)">LA</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get int at current input pointer + i ahead where i=1 is next int.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.antlr.runtime.Token</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#LT(int)">LT</A></B>(int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get Token at current input pointer + i ahead where i=1 is next Token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#mark()">mark</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tell the stream to start buffering if it hasn't already.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#release(int)">release</A></B>(int&nbsp;marker)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You may want to commit to a backtrack but don't want to force the
 stream to keep bookkeeping objects around for a marker that is
 no longer necessary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.antlr.runtime.TokenSource</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#replaceTokenSource(org.antlr.runtime.TokenSource)">replaceTokenSource</A></B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows to replace the current token source with the given one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#rewind()">rewind</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rewind to the input position of the last marker.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#rewind(int)">rewind</A></B>(int&nbsp;marker)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reset the stream so that next call to index would return marker.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#seek(int)">seek</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the input cursor to the position indicated by index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#setDiscardOffChannelTokens(boolean)">setDiscardOffChannelTokens</A></B>(boolean&nbsp;discardOffChannelTokens)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instructs this token stream to discard any tokens not associated with the default token channel when they
 are encountered depending on the value of the given parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#setTokenSource(org.antlr.runtime.TokenSource)">setTokenSource</A></B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installs the given token source as the token source to read tokens from.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#setTokenTypeChannel(int, int)">setTokenTypeChannel</A></B>(int&nbsp;ttype,
                    int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instructs this token stream to associate tokens of the given type with the given token channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unsupported operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#toString(int, int)">toString</A></B>(int&nbsp;start,
         int&nbsp;stop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unsupported operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#toString(org.antlr.runtime.Token, org.antlr.runtime.Token)">toString</A></B>(org.antlr.runtime.Token&nbsp;start,
         org.antlr.runtime.Token&nbsp;stop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unsupported operation.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LazyTokenStream()"><!-- --></A><H3>
LazyTokenStream</H3>
<PRE>
public <B>LazyTokenStream</B>()</PRE>
<DL>
<DD>Creates a new <code>LazyTokenStream</code>. With this constructor a token source has to be specified
 separatly via the <A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyTokenStream.html#setTokenSource(org.antlr.runtime.TokenSource)"><CODE>setTokenSource(org.antlr.runtime.TokenSource)</CODE></A> method.
<P>
</DL>
<HR>

<A NAME="LazyTokenStream(org.antlr.runtime.TokenSource)"><!-- --></A><H3>
LazyTokenStream</H3>
<PRE>
public <B>LazyTokenStream</B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</PRE>
<DL>
<DD>Creates a new <code>LazyTokenStream</code> reading tokens from the given token source.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>tokenSource</CODE> - the token source to read tokens from.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LT(int)"><!-- --></A><H3>
LT</H3>
<PRE>
public org.antlr.runtime.Token <B>LT</B>(int&nbsp;k)</PRE>
<DL>
<DD>Get Token at current input pointer + i ahead where i=1 is next Token.
 i<0 indicates tokens in the past.  So -1 is previous token and -2 is
 two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
 Return null for LT(0) and any index that results in an absolute address
 that is negative.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>LT</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="LA(int)"><!-- --></A><H3>
LA</H3>
<PRE>
public int <B>LA</B>(int&nbsp;i)</PRE>
<DL>
<DD>Get int at current input pointer + i ahead where i=1 is next int.
 Negative indexes are allowed.  LA(-1) is previous token (token
 just matched).  LA(-i) where i is before first token should
 yield -1, invalid char / EOF.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>LA</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="consume()"><!-- --></A><H3>
consume</H3>
<PRE>
public void <B>consume</B>()</PRE>
<DL>
<DD>Consumes the next token.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>consume</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="collectOffChannelTokenText(int)"><!-- --></A><H3>
collectOffChannelTokenText</H3>
<PRE>
public java.lang.String <B>collectOffChannelTokenText</B>(int&nbsp;collectChannel)</PRE>
<DL>
<DD>Collects the tokens associated with the given token channel starting from the first look-ahead token up to the
 next token associated with the default token channel. Returns the collected tokens' text in a string.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>collectChannel</CODE> - the token channel to collect tokens for.
<DT><B>Returns:</B><DD>a string made up from the text of the collected tokens.</DL>
</DD>
</DL>
<HR>

<A NAME="get(int)"><!-- --></A><H3>
get</H3>
<PRE>
public org.antlr.runtime.Token <B>get</B>(int&nbsp;i)</PRE>
<DL>
<DD>Unsupported operation. Do not use.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>get</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.UnsupportedOperationException</CODE> - in case you cannot resist to use this method.</DL>
</DD>
</DL>
<HR>

<A NAME="mark()"><!-- --></A><H3>
mark</H3>
<PRE>
public int <B>mark</B>()</PRE>
<DL>
<DD>Tell the stream to start buffering if it hasn't already.  Return
 current input position, index(), or some other marker so that
 when passed to rewind() you get back to the same spot.
 rewind(mark()) should not affect the input cursor.  The Lexer
 track line/col info as well as input index so its markers are
 not pure input indexes.  Same for tree node streams.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>mark</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="index()"><!-- --></A><H3>
index</H3>
<PRE>
public int <B>index</B>()</PRE>
<DL>
<DD>Return the current input symbol index 0..n where n indicates the
 last symbol has been read.  The index is the symbol about to be
 read not the most recently read symbol.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>index</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rewind(int)"><!-- --></A><H3>
rewind</H3>
<PRE>
public void <B>rewind</B>(int&nbsp;marker)</PRE>
<DL>
<DD>Reset the stream so that next call to index would return marker.
 The marker will usually be index() but it doesn't have to be.  It's
 just a marker to indicate what state the stream was in.  This is
 essentially calling release() and seek().  If there are markers
 created after this marker argument, this routine must unroll them
 like a stack.  Assume the state the stream was in when this marker
 was created.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>rewind</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rewind()"><!-- --></A><H3>
rewind</H3>
<PRE>
public void <B>rewind</B>()</PRE>
<DL>
<DD>Rewind to the input position of the last marker.
 Used currently only after a cyclic DFA and just
 before starting a sem/syn predicate to get the
 input position back to the start of the decision.
 Do not "pop" the marker off the state.  mark(i)
 and rewind(i) should balance still. It is
 like invoking rewind(last marker) but it should not "pop"
 the marker off.  It's like seek(last marker's input position).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>rewind</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="release(int)"><!-- --></A><H3>
release</H3>
<PRE>
public void <B>release</B>(int&nbsp;marker)</PRE>
<DL>
<DD>You may want to commit to a backtrack but don't want to force the
 stream to keep bookkeeping objects around for a marker that is
 no longer necessary.  This will have the same behavior as
 rewind() except it releases resources without the backward seek.
 This must throw away resources for all markers back to the marker
 argument.  So if you're nested 5 levels of mark(), and then release(2)
 you have to release resources for depths 2..5.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>release</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="seek(int)"><!-- --></A><H3>
seek</H3>
<PRE>
public void <B>seek</B>(int&nbsp;index)</PRE>
<DL>
<DD>Set the input cursor to the position indicated by index.  This is
 normally used to seek ahead in the input stream.  No buffering is
 required to do this unless you know your stream will use seek to
 move backwards such as when backtracking.
 <p/>
 This is different from rewind in its multi-directional
 requirement and in that its argument is strictly an input cursor (index).
 <p/>
 For char streams, seeking forward must update the stream state such
 as line number.  For seeking backwards, you will be presumably
 backtracking using the mark/rewind mechanism that restores state and
 so this method does not need to update state when seeking backwards.
 <p/>
 Currently, this method is only used for efficient backtracking using
 memoization, but in the future it may be used for incremental parsing.
 <p/>
 The index is 0..n-1.  A seek to position i means that LA(1) will
 return the ith symbol.  So, seeking to 0 means LA(1) will return the
 first element in the stream.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>seek</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public int <B>size</B>()</PRE>
<DL>
<DD>Unsupported operation. Do not use.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>size</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.UnsupportedOperationException</CODE> - in case you cannot resist to use this method.</DL>
</DD>
</DL>
<HR>

<A NAME="getSourceName()"><!-- --></A><H3>
getSourceName</H3>
<PRE>
public java.lang.String <B>getSourceName</B>()</PRE>
<DL>
<DD>Where are you getting symbols from?  Normally, implementations will
 pass the buck all the way to the lexer who can ask its input stream
 for the file name or whatever.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getSourceName</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenSource()"><!-- --></A><H3>
getTokenSource</H3>
<PRE>
public org.antlr.runtime.TokenSource <B>getTokenSource</B>()</PRE>
<DL>
<DD>Where is this stream pulling tokens from?  This is not the name, but
 the object that provides Token objects.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getTokenSource</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTokenSource(org.antlr.runtime.TokenSource)"><!-- --></A><H3>
setTokenSource</H3>
<PRE>
public void <B>setTokenSource</B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</PRE>
<DL>
<DD>Installs the given token source as the token source to read tokens from. Implicitly resets this token stream.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tokenSource</CODE> - the token source read tokens from.</DL>
</DD>
</DL>
<HR>

<A NAME="replaceTokenSource(org.antlr.runtime.TokenSource)"><!-- --></A><H3>
replaceTokenSource</H3>
<PRE>
public org.antlr.runtime.TokenSource <B>replaceTokenSource</B>(org.antlr.runtime.TokenSource&nbsp;tokenSource)</PRE>
<DL>
<DD>Allows to replace the current token source with the given one. This token stream's state is preserved.
 Any look-ahead is discarded.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tokenSource</CODE> - the token source to read tokens from.
<DT><B>Returns:</B><DD>the token source replaced by the given one.</DL>
</DD>
</DL>
<HR>

<A NAME="discardLookAhead()"><!-- --></A><H3>
discardLookAhead</H3>
<PRE>
public void <B>discardLookAhead</B>()</PRE>
<DL>
<DD>Discards any look-ahead. That is tokens that have been read but not consumed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTokenTypeChannel(int, int)"><!-- --></A><H3>
setTokenTypeChannel</H3>
<PRE>
public void <B>setTokenTypeChannel</B>(int&nbsp;ttype,
                                int&nbsp;channel)</PRE>
<DL>
<DD>Instructs this token stream to associate tokens of the given type with the given token channel.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ttype</CODE> - the token type.<DD><CODE>channel</CODE> - the token channel.</DL>
</DD>
</DL>
<HR>

<A NAME="discardTokenType(int)"><!-- --></A><H3>
discardTokenType</H3>
<PRE>
public void <B>discardTokenType</B>(int&nbsp;tokenType)</PRE>
<DL>
<DD>Instructs this token stream to discard any tokens of the given type when they are encountered.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tokenType</CODE> - the token type.</DL>
</DD>
</DL>
<HR>

<A NAME="isDiscardOffChannelTokens()"><!-- --></A><H3>
isDiscardOffChannelTokens</H3>
<PRE>
public boolean <B>isDiscardOffChannelTokens</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if tokens not associated with the default token channel are discarded by this token
 stream.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if tokens are discarded.</DL>
</DD>
</DL>
<HR>

<A NAME="setDiscardOffChannelTokens(boolean)"><!-- --></A><H3>
setDiscardOffChannelTokens</H3>
<PRE>
public void <B>setDiscardOffChannelTokens</B>(boolean&nbsp;discardOffChannelTokens)</PRE>
<DL>
<DD>Instructs this token stream to discard any tokens not associated with the default token channel when they
 are encountered depending on the value of the given parameter.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>discardOffChannelTokens</CODE> - if <code>true</code>, tokens will be discarded.</DL>
</DD>
</DL>
<HR>

<A NAME="toString(int, int)"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>(int&nbsp;start,
                                 int&nbsp;stop)</PRE>
<DL>
<DD>Unsupported operation. Do not use.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>toString</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.UnsupportedOperationException</CODE> - in case you cannot resist to use this method.</DL>
</DD>
</DL>
<HR>

<A NAME="toString(org.antlr.runtime.Token, org.antlr.runtime.Token)"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>(org.antlr.runtime.Token&nbsp;start,
                                 org.antlr.runtime.Token&nbsp;stop)</PRE>
<DL>
<DD>Unsupported operation. Do not use.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>toString</CODE> in interface <CODE>org.antlr.runtime.TokenStream</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.UnsupportedOperationException</CODE> - in case you cannot resist to use this method.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LazyTokenStream.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyLexer.html" title="class in org.unbunt.ella.compiler.antlr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/unbunt/ella/compiler/antlr/LazyTokenStream.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LazyTokenStream.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
