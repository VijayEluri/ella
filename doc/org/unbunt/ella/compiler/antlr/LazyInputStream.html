<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_14) on Sun Aug 16 00:24:47 CEST 2009 -->
<TITLE>
LazyInputStream
</TITLE>

<META NAME="date" CONTENT="2009-08-16">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="LazyInputStream";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LazyInputStream.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputBuffer.html" title="class in org.unbunt.ella.compiler.antlr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyLexer.html" title="class in org.unbunt.ella.compiler.antlr"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/unbunt/ella/compiler/antlr/LazyInputStream.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LazyInputStream.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.unbunt.ella.compiler.antlr</FONT>
<BR>
Class LazyInputStream</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>org.unbunt.ella.compiler.antlr.LazyInputStream</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>org.antlr.runtime.CharStream, org.antlr.runtime.IntStream</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>LazyInputStream</B><DT>extends java.lang.Object<DT>implements org.antlr.runtime.CharStream</DL>
</PRE>

<P>
Represents a <code>CharStream</code> implementation which reads characters from a given stream
 lazily when they are requested instead of eagerly on instanciation. In addition any characters
 no longer needed are discarded by this char stream.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_org.antlr.runtime.CharStream"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface org.antlr.runtime.CharStream</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>EOF</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#LazyInputStream(java.io.InputStream)">LazyInputStream</A></B>(java.io.InputStream&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>LazyInputStream</code> reading characters from the given input stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#LazyInputStream(java.io.Reader)">LazyInputStream</A></B>(java.io.Reader&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>LazyInputStream</code> reading characters from the given <code>Reader</code>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#buffer()">buffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instructs this input stream to start buffering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#consume()">consume</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Consumes the next character.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#getCharPositionInLine()">getCharPositionInLine</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The index of the character relative to the beginning of the line 0..n-1</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#getLine()">getLine</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ANTLR tracks the line information automatically</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#getSourceName()">getSourceName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where are you getting symbols from?  Normally, implementations will
 pass the buck all the way to the lexer who can ask its input stream
 for the file name or whatever.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#index()">index</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the current input symbol index 0..n where n indicates the
 last symbol has been read.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#LA(int)">LA</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get int at current input pointer + i ahead where i=1 is next int.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#LT(int)">LT</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the ith character of lookahead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#mark()">mark</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tell the stream to start buffering if it hasn't already.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#release(int)">release</A></B>(int&nbsp;marker)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You may want to commit to a backtrack but don't want to force the
 stream to keep bookkeeping objects around for a marker that is
 no longer necessary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#rewind()">rewind</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rewind to the input position of the last marker.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#rewind(int)">rewind</A></B>(int&nbsp;marker)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reset the stream so that next call to index would return marker.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#seek(int)">seek</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the input cursor to the position indicated by index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#setCharPositionInLine(int)">setCharPositionInLine</A></B>(int&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#setLine(int)">setLine</A></B>(int&nbsp;line)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Because this stream can rewind, we need to be able to reset the line</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#setSourceName(java.lang.String)">setSourceName</A></B>(java.lang.String&nbsp;sourceName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only makes sense for streams that buffer everything up probably, but
 might be useful to display the entire stream or for testing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#substring(int, int)">substring</A></B>(int&nbsp;start,
          int&nbsp;stop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For infinite streams, you don't need this; primarily I'm providing
 a useful interface for action code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#unbuffer(int)">unbuffer</A></B>(int&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Releases the specified buffer.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LazyInputStream(java.io.Reader)"><!-- --></A><H3>
LazyInputStream</H3>
<PRE>
public <B>LazyInputStream</B>(java.io.Reader&nbsp;input)</PRE>
<DL>
<DD>Creates a new <code>LazyInputStream</code> reading characters from the given <code>Reader</code>.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the character source.</DL>
</DL>
<HR>

<A NAME="LazyInputStream(java.io.InputStream)"><!-- --></A><H3>
LazyInputStream</H3>
<PRE>
public <B>LazyInputStream</B>(java.io.InputStream&nbsp;input)</PRE>
<DL>
<DD>Creates a new <code>LazyInputStream</code> reading characters from the given input stream.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the character source.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="substring(int, int)"><!-- --></A><H3>
substring</H3>
<PRE>
public java.lang.String <B>substring</B>(int&nbsp;start,
                                  int&nbsp;stop)</PRE>
<DL>
<DD>For infinite streams, you don't need this; primarily I'm providing
 a useful interface for action code.  Just make sure actions don't
 use this on streams that don't support it.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>substring</CODE> in interface <CODE>org.antlr.runtime.CharStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="LT(int)"><!-- --></A><H3>
LT</H3>
<PRE>
public int <B>LT</B>(int&nbsp;i)</PRE>
<DL>
<DD>Get the ith character of lookahead.  This is the same usually as
 LA(i).  This will be used for labels in the generated
 lexer code.  I'd prefer to return a char here type-wise, but it's
 probably better to be 32-bit clean and be consistent with LA.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>LT</CODE> in interface <CODE>org.antlr.runtime.CharStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="LA(int)"><!-- --></A><H3>
LA</H3>
<PRE>
public int <B>LA</B>(int&nbsp;i)</PRE>
<DL>
<DD>Get int at current input pointer + i ahead where i=1 is next int.
 Negative indexes are allowed.  LA(-1) is previous token (token
 just matched).  LA(-i) where i is before first token should
 yield -1, invalid char / EOF.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>LA</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="mark()"><!-- --></A><H3>
mark</H3>
<PRE>
public int <B>mark</B>()</PRE>
<DL>
<DD>Tell the stream to start buffering if it hasn't already.  Return
 current input position, index(), or some other marker so that
 when passed to rewind() you get back to the same spot.
 rewind(mark()) should not affect the input cursor.  The Lexer
 track line/col info as well as input index so its markers are
 not pure input indexes.  Same for tree node streams.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>mark</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rewind(int)"><!-- --></A><H3>
rewind</H3>
<PRE>
public void <B>rewind</B>(int&nbsp;marker)</PRE>
<DL>
<DD>Reset the stream so that next call to index would return marker.
 The marker will usually be index() but it doesn't have to be.  It's
 just a marker to indicate what state the stream was in.  This is
 essentially calling release() and seek().  If there are markers
 created after this marker argument, this routine must unroll them
 like a stack.  Assume the state the stream was in when this marker
 was created.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>rewind</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rewind()"><!-- --></A><H3>
rewind</H3>
<PRE>
public void <B>rewind</B>()</PRE>
<DL>
<DD>Rewind to the input position of the last marker.
 Used currently only after a cyclic DFA and just
 before starting a sem/syn predicate to get the
 input position back to the start of the decision.
 Do not "pop" the marker off the state.  mark(i)
 and rewind(i) should balance still. It is
 like invoking rewind(last marker) but it should not "pop"
 the marker off.  It's like seek(last marker's input position).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>rewind</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="release(int)"><!-- --></A><H3>
release</H3>
<PRE>
public void <B>release</B>(int&nbsp;marker)</PRE>
<DL>
<DD>You may want to commit to a backtrack but don't want to force the
 stream to keep bookkeeping objects around for a marker that is
 no longer necessary.  This will have the same behavior as
 rewind() except it releases resources without the backward seek.
 This must throw away resources for all markers back to the marker
 argument.  So if you're nested 5 levels of mark(), and then release(2)
 you have to release resources for depths 2..5.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>release</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="buffer()"><!-- --></A><H3>
buffer</H3>
<PRE>
public int <B>buffer</B>()</PRE>
<DL>
<DD>Instructs this input stream to start buffering. Contrary to the stack like (LIFO) semantics achieved with the
 <code>mark</code> and <code>release</code>/<code>rewind</code> methods the buffering is done using
 queue like (FIFO) semantics.
 <p>
 For every call to this method there must be a matching call to the unbuffer method to release the buffered
 characters.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a handle marking this buffer's start. For ease of use with other components this handle is identical
         with the current offset in the stream.<DT><B>See Also:</B><DD><A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputStream.html#unbuffer(int)"><CODE>unbuffer(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unbuffer(int)"><!-- --></A><H3>
unbuffer</H3>
<PRE>
public void <B>unbuffer</B>(int&nbsp;buffer)</PRE>
<DL>
<DD>Releases the specified buffer. If there are no markers registered within this stream and there is no buffer
 starting at a smaller offset in the stream the characters buffered for the specified handle are released up
 to the next buffer or the current offset in the stream, whichever comes first.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - the handle specifying the buffer to release.</DL>
</DD>
</DL>
<HR>

<A NAME="seek(int)"><!-- --></A><H3>
seek</H3>
<PRE>
public void <B>seek</B>(int&nbsp;index)</PRE>
<DL>
<DD>Set the input cursor to the position indicated by index.  This is
 normally used to seek ahead in the input stream.  No buffering is
 required to do this unless you know your stream will use seek to
 move backwards such as when backtracking.
 <p/>
 This is different from rewind in its multi-directional
 requirement and in that its argument is strictly an input cursor (index).
 <p/>
 For char streams, seeking forward must update the stream state such
 as line number.  For seeking backwards, you will be presumably
 backtracking using the mark/rewind mechanism that restores state and
 so this method does not need to update state when seeking backwards.
 <p/>
 Currently, this method is only used for efficient backtracking using
 memoization, but in the future it may be used for incremental parsing.
 <p/>
 The index is 0..n-1.  A seek to position i means that LA(1) will
 return the ith symbol.  So, seeking to 0 means LA(1) will return the
 first element in the stream.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>seek</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="consume()"><!-- --></A><H3>
consume</H3>
<PRE>
public void <B>consume</B>()</PRE>
<DL>
<DD>Consumes the next character.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>consume</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="index()"><!-- --></A><H3>
index</H3>
<PRE>
public int <B>index</B>()</PRE>
<DL>
<DD>Return the current input symbol index 0..n where n indicates the
 last symbol has been read.  The index is the symbol about to be
 read not the most recently read symbol.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>index</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public int <B>size</B>()</PRE>
<DL>
<DD>Only makes sense for streams that buffer everything up probably, but
 might be useful to display the entire stream or for testing.  This
 value includes a single EOF.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>size</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLine()"><!-- --></A><H3>
getLine</H3>
<PRE>
public int <B>getLine</B>()</PRE>
<DL>
<DD>ANTLR tracks the line information automatically
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getLine</CODE> in interface <CODE>org.antlr.runtime.CharStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLine(int)"><!-- --></A><H3>
setLine</H3>
<PRE>
public void <B>setLine</B>(int&nbsp;line)</PRE>
<DL>
<DD>Because this stream can rewind, we need to be able to reset the line
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setLine</CODE> in interface <CODE>org.antlr.runtime.CharStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCharPositionInLine()"><!-- --></A><H3>
getCharPositionInLine</H3>
<PRE>
public int <B>getCharPositionInLine</B>()</PRE>
<DL>
<DD>The index of the character relative to the beginning of the line 0..n-1
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getCharPositionInLine</CODE> in interface <CODE>org.antlr.runtime.CharStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCharPositionInLine(int)"><!-- --></A><H3>
setCharPositionInLine</H3>
<PRE>
public void <B>setCharPositionInLine</B>(int&nbsp;pos)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setCharPositionInLine</CODE> in interface <CODE>org.antlr.runtime.CharStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSourceName()"><!-- --></A><H3>
getSourceName</H3>
<PRE>
public java.lang.String <B>getSourceName</B>()</PRE>
<DL>
<DD>Where are you getting symbols from?  Normally, implementations will
 pass the buck all the way to the lexer who can ask its input stream
 for the file name or whatever.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getSourceName</CODE> in interface <CODE>org.antlr.runtime.IntStream</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSourceName(java.lang.String)"><!-- --></A><H3>
setSourceName</H3>
<PRE>
public void <B>setSourceName</B>(java.lang.String&nbsp;sourceName)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LazyInputStream.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyInputBuffer.html" title="class in org.unbunt.ella.compiler.antlr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/unbunt/ella/compiler/antlr/LazyLexer.html" title="class in org.unbunt.ella.compiler.antlr"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/unbunt/ella/compiler/antlr/LazyInputStream.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LazyInputStream.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
