SQL-Statement-Expression
-> SQLLiteralExpression
-> raw query string
-> Conn.createStmt(rawQuery)
-> Stmt

SQL-Statement
-> SQLLiteralExpression
-> raw query string
-> Conn.executeStmt(rawQuery)
	-> Conn.createStmt
	-> Stmt.do

/*
 * TODO: Methoden fuer explizites Resourcen-Management in Conn, Stmt
 *       (auch hinsichtlich TX-Verwaltung)
 * TODO: XA-Verbindungen
 */

-- called internally only
ConnMgr.new(conn):
	this.activeConn = conn; -- maybe null

ConnMgr.create(url, closure):
	Connection connection = DataSource.getConnection();
	Conn conn = new Conn(this, connection);
	if (closure == null) {
		if (this.activeConn == null) {
			this.activeConn = conn;
		}
		return conn;
	}
	conn.do(closure);
	conn.close();
	return null;

ConnMgr.activate(conn):
	var prevConn = this.activeConn;
	this.activeConn = conn;
	return prevConn;

ConnMgr.proxy(engine, context, args):
	if (this.activeConn == null) {
		throw new Exception("not connected");
	}
	Str funcName = args[0];
	Obj[] funcArgs = args[1];
	Obj invokable = ObjUtils.getSlot(this.activeConn, funcName);
	engine.trigger(invokable, this.activeConn, funcArgs);

ConnMgr.getSlot(name):
	Obj value = this.slots.get(name);
	if (value == null) {
		// XXX: proceed with lookup in parent?
		// NOTE: proxying does work for methods only, not for properties
		return this.proxy;
	}

Conn.new(mgr, connection):
	-- circular reference - use interface for mgr
	this.mgr = mgr;
	this.connection = connection;

Conn.do(closure):
	var prevConn = this.mgr.activate(this);
	Engine.invoke(closure);
	this.mgr.activate(prevConn);

Conn.createStmt(queryString):
	var stmt := new Stmt(queryString, this.connection, !this.keepResources);
	if (!this.keepResources) {
		this.managedStmts.add(stmt);
	}

Conn.withPrepared(closure):
	this.keepResources = true;
	Engine.invoke(closure);
	this.flushStmts();
	this.keepResources = false;

Conn.flushStmts():
	for stmt in this.managedStmts) {
		stmt.close();
	}

Conn.executeStmt(queryString):
	if (this.batchActive) {
		this.batchStmt.add(queryString);
		return;
	}
	Stmt stmt = new Stmt(this.connection, queryString);
	stmt.do();
}

-- Also active connection? (-> to avoid Conn.do { Conn.batch { } })
Conn.batch(closure, size):
	if (size == null) {
		size = Engine.getDefaultBatchSize();
	}
	if (this.batchActive) {
		-- possibly issue a warning
		Engine.invoke(closure);
		return;
	}
	this.batchActive = true;
	this.batchStmt = new StmtBatch(this.connection, size);
	Engine.invoke(closure);
	this.batchStmt.flush();
	this.batchStmt.close();
	this.batchStmt = null;
	this.batchActive = false;

StmtBatch.new(connection, size):
	this.statement = connection.createStatement();
	this.size = size;
	this.k = 0;

StmtBatch.add(queryString):
	this.k++;
	this.statement.addBatch(queryString);
	if (this.k % this.size == 0) {
		this.statement.executeBatch();
		-- possibly notify observers
	}
	this.statement.clearBatch();

StmtBatch.flush():
	if (this.k == 0) return;
	this.statement.executeBatch();
	-- possibly notify observers

StmtBatch.close():
	this.statement.close();

Stmt.new(rawQuery, connection, manageResources):
	this.connection = connection;
	this.queryString = rawQuery;
	this.statement = null
	this.prepared = false;
	this.initialized = false;
	this.keepResources = false;
	this.manageResources = false;

Stmt.init:
	if (this.initialized) return;
	this.statement =
		this.connection.createStatement(this.rawQuery);
	this.initialized = true;

Stmt.initPrepared:
	if (this.initialized) {
		if (!this.prepared) {
			throw new Exception("not a prepared stmt");
		}
		return;
	}
	this.statment =
		this.connection.prepareStatement(this.rawQuery);
	this.prepared = true;
	this.initialized = true;
	this.keepResources = false;

Stmt.close:
	if (!this.initialized) return;
	if (!this.manageResources || this.keepResources) return;
	this.statement.close();
	this.prepared = false;
	this.initialized = false;

Stmt.do:
	this.init();
	boolean hasResult = this.statement.execute();
	if (hasResult) {
		Engine.notifyResultSet(this.statement.getResultSet());
	}
	else {
		Engine.notifyUpdateCount(this.statement.getUpdateCount());
	}
	this.close();

Stmt.with(params):
	this.initPrepared();
	((PreparedStatement)this.statement).clearParameters();
	for i (1..params.length) {
		((PreparedStatement) this.statement)
			.setObject(i, params[i]);
	}

Stmt.withPrepared(closure):
	this.initPrepared();
	this.keepResources = true;
	Engine.invoke(closure, this);
	this.keepResources = false;
	this.close();

Stmt.each(closure):
	this.init();
	// may throw exception if query doesn't return result set
	ResultSet rs = this.statement.executeQuery();
	while (rs.next()) {
		var resArray := // put values in array
		Engine.invoke(closure, resArray);
	}
	rs.close();
	this.close();

Stmt.eachRow(closure):
	this.init();
	ResultSet rs = this.statement.executeQuery();
	ResultSetMetadata meta = rs.getMetadata();
	ResSet wrs = new ResSet(rs);
	while (wrs.next()) {
		Engine.invoke(closure, wrs, meta);
	}
	wrs.close();
	this.close();

Stmt.batch(size, closure):
	if (size == null) {
		size = Engine.getDefaultBatchSize();
	}
	this.initPrepared();
	ParamBatch batch = new ParamBatch(this.statement, size);
	Engine.invoke(closure, batch);
	batch.finish();
	this.close();

ParamBatch.new(statement, size):
	this.statement = statement;
	this.size = size;
	this.k = 0;

ParamBatch.add(params):
	this.k++;
	this.statement.addParams(params);
	if (this.k % this.size == 0) {
		this.statement.execute();
		this.k = 0;
	}

ParamBatch.finish():
	if (this.k == 0) return;
	this.statement.execute();
